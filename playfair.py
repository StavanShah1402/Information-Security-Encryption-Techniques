# -*- coding: utf-8 -*-
"""Playfair

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MwZ2B6griBOkCmvvwnl9ZXQj8c2v01BO
"""

list_w_i = 'ABCDEFGHIJKLMNOPQRSTUVWXY'
list_w_y = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'

def matrix(key):
  unique_key = []
  for char in key:
      if char not in unique_key:
          unique_key.append(char)

  complete_list = []
  if 'I' in unique_key or 'J' in unique_key:
      for char in unique_key:
          if char not in complete_list:
              complete_list.append(char)
      for char in list_w_i:
          if char not in complete_list:
              complete_list.append(char)
  elif 'Y' in unique_key or 'Z' in unique_key:
      for char in unique_key:
          if char not in complete_list:
              complete_list.append(char)
      for char in list_w_y:
          if char not in complete_list:
              complete_list.append(char)
  else:
      for char in unique_key:
          if char not in complete_list:
              complete_list.append(char)
      for char in list_w_i:
          if char not in complete_list:
              complete_list.append(char)
  mat = []
  while complete_list != []:
      mat.append(complete_list[:5])
      complete_list = complete_list[5:]
  return mat

def seperate_pt(pt):
  n = len(pt)
  i = 0
  while i < (n-1):
      if pt[i] == pt[i+1] and pt[i] != 'Y':
          pt = pt[:i+1] + 'Y' + pt[i+1:]
          n = len(pt)

      elif pt[i] == pt[i+1] and pt[i] == 'Y':
          pt = pt[:i+1] + 'Z' + pt[i+1:]
          n = len(pt)
      
      i += 1
  n = len(pt)
  if n % 2 == 1:
      pt += 'X'

  sep_pt = []
  while(pt != ''):
      sep_pt.append(pt[:2])
      pt = pt[2:]
      
  return sep_pt

def get_index_pairs(sep_pt, mat):
  ind = {}
  for pairs in sep_pt:
      pair_inx = []
      char1, char2 = pairs[0], pairs[1]
      for inx, row in enumerate(mat):
          if char1 in row:
              pair_inx1 = [inx, row.index(char1)]

          if char2 in row:
              pair_inx2 = [inx, row.index(char2)]
      pair_inx.append(pair_inx1)
      pair_inx.append(pair_inx2)
      ind[str(pairs)] = pair_inx
  return ind
def pf_encryption(sep_pt, mat):
  ind = get_index_pairs(sep_pt, mat)
  print('\n\nINDICES OF CHAR IN PAIRS:\n')
  for key in ind.keys():
      print(key, ind[key])
  ct_list = []
  print('\n\nCIPHERING EACH PAIRS')
  for key in ind.keys():
      char_inx1, char_inx2 = ind[key][0], ind[key][1]
      char1_row, char1_col = char_inx1[0], char_inx1[1]
      char2_row, char2_col = char_inx2[0], char_inx2[1]
      if char1_row == char2_row:
          new = [mat[char1_row][(char1_col+1)%5], mat[char2_row][(char2_col+1)%5]]
      elif char1_col == char2_col:
          new = [mat[(char1_row+1)%5][char1_col], mat[(char2_row+1)%5][char2_col]]
      else:
          new = [mat[char1_row][char2_col], mat[char2_row][char1_col]]
      print(key, '-->', (str(new[0])+str(new[1])))
      ct_list.append(new)
  ct = ''
  for row in ct_list:
      ct += row[0]
      ct += row[1]
  return ct
pt = 'INSTRUMENTS'
key = 'MONARCHY'

print('\nPLAIN TEXT:', pt)
print('\nKEY:', key)
print('\n\n5x5 TABLE:\n')
mat = matrix(key)
for row in mat:
    print(row)
print('\n\nPAIRS IN PLAIN TEXT:\n')
sep_pt = seperate_pt(pt)
print(sep_pt)

ct = pf_encryption(sep_pt, mat)
print('\n\nCIPHERED TEXT:', ct)

pt = 'SUBCONTINENT'
key = 'INDIAN'

print('\nPLAIN TEXT:', pt)
print('\nKEY:', key)

print('\n\n5x5 TABLE:\n')
mat = matrix(key)
for row in mat:
    print(row)

print('\n\nPAIRS IN PLAIN TEXT:\n')
sep_pt = seperate_pt(pt)
print(sep_pt)

ct = pf_encryption(sep_pt, mat)
print('\n\nCIPHERED TEXT:', ct)

